pipeline {
    agent any
    
    parameters {
        string(name: 'PROJECT_NAME', defaultValue: 'fashion-recommendation-api', description: 'Project name to deploy')
        string(name: 'GIT_REPO', defaultValue: 'https://github.com/hyeminkim11230/fashion-recommendation-api.git', description: 'Git repository URL')
        string(name: 'GIT_BRANCH', defaultValue: 'main', description: 'Git branch to deploy')
        choice(name: 'ENVIRONMENT', choices: ['development', 'staging', 'production'], description: 'Target environment')
        string(name: 'DOCKER_REGISTRY', defaultValue: 'docker.io', description: 'Docker registry URL')
        string(name: 'DOCKER_NAMESPACE', defaultValue: 'hyeminkim11230', description: 'Docker namespace/username')
    }
    
    environment {
        DOCKER_IMAGE = "${params.DOCKER_NAMESPACE}/${params.PROJECT_NAME}"
        KUBECONFIG = '/var/lib/jenkins/.kube/config'
        SLACK_CHANNEL = '#deployments'
        BUILD_NUMBER_TAG = "${BUILD_NUMBER}"
        GIT_COMMIT_SHORT = "${GIT_COMMIT.take(7)}"
    }
    
    tools {
        dockerTool 'docker'
    }
    
    stages {
        stage('üèÅ Initialize') {
            steps {
                script {
                    echo "üöÄ Starting deployment pipeline for ${params.PROJECT_NAME}"
                    echo "üìã Environment: ${params.ENVIRONMENT}"
                    echo "üåø Branch: ${params.GIT_BRANCH}"
                    echo "üê≥ Docker Image: ${DOCKER_IMAGE}:${BUILD_NUMBER_TAG}"
                    
                    // Slack notification - Start
                    try {
                        slackSend(
                            channel: env.SLACK_CHANNEL,
                            color: 'warning',
                            message: "üöÄ *${params.PROJECT_NAME}* deployment started\\n" +
                                   "üìã Environment: `${params.ENVIRONMENT}`\\n" +
                                   "üåø Branch: `${params.GIT_BRANCH}`\\n" +
                                   "üë∑ Build: `#${BUILD_NUMBER}`\\n" +
                                   "üîó <${BUILD_URL}|View Build>"
                        )
                    } catch (Exception e) {
                        echo "Slack notification failed: ${e.getMessage()}"
                    }
                }
            }
        }
        
        stage('üì• Checkout Source Code') {
            steps {
                script {
                    echo "üì• Checking out source code from ${params.GIT_REPO}"
                    
                    // Clean workspace
                    deleteDir()
                    
                    // Checkout source code
                    checkout([
                        $class: 'GitSCM',
                        branches: [[name: "*/${params.GIT_BRANCH}"]],
                        userRemoteConfigs: [[url: params.GIT_REPO]]
                    ])
                    
                    // Get commit info
                    env.GIT_COMMIT_MSG = sh(
                        script: 'git log -1 --pretty=format:"%s"',
                        returnStdout: true
                    ).trim()
                    
                    echo "‚úÖ Source code checked out successfully"
                    echo "üìù Latest commit: ${env.GIT_COMMIT_MSG}"
                }
            }
        }
        
        stage('üß™ Run Tests') {
            when {
                expression { fileExists('requirements.txt') || fileExists('package.json') }
            }
            steps {
                script {
                    echo "üß™ Running tests for ${params.PROJECT_NAME}"
                    
                    if (fileExists('requirements.txt')) {
                        // Python tests
                        sh '''
                            python3 -m venv venv
                            source venv/bin/activate
                            pip install -r requirements.txt
                            pip install pytest pytest-cov
                            
                            # Run tests if test directory exists
                            if [ -d "tests" ]; then
                                python -m pytest tests/ --cov=app --cov-report=xml --cov-report=html
                            else
                                echo "No tests directory found, skipping tests"
                            fi
                        '''
                    } else if (fileExists('package.json')) {
                        // Node.js tests
                        sh '''
                            npm install
                            npm test || echo "No tests defined"
                        '''
                    }
                    
                    echo "‚úÖ Tests completed"
                }
            }
        }
        
        stage('üê≥ Build Docker Image') {
            steps {
                script {
                    echo "üê≥ Building Docker image: ${DOCKER_IMAGE}:${BUILD_NUMBER_TAG}"
                    
                    // Build Docker image
                    def dockerImage = docker.build("${DOCKER_IMAGE}:${BUILD_NUMBER_TAG}")
                    
                    // Tag as latest for the environment
                    sh "docker tag ${DOCKER_IMAGE}:${BUILD_NUMBER_TAG} ${DOCKER_IMAGE}:${params.ENVIRONMENT}-latest"
                    
                    echo "‚úÖ Docker image built successfully"
                    
                    // Store image info
                    env.DOCKER_IMAGE_FULL = "${DOCKER_IMAGE}:${BUILD_NUMBER_TAG}"
                }
            }
        }
        
        stage('üîê Security Scan') {
            steps {
                script {
                    echo "üîê Running security scan on Docker image"
                    
                    try {
                        // Docker image vulnerability scan (using trivy if available)
                        sh '''
                            if command -v trivy &> /dev/null; then
                                trivy image --exit-code 0 --severity HIGH,CRITICAL ${DOCKER_IMAGE_FULL}
                            else
                                echo "Trivy not installed, skipping security scan"
                                echo "To install: sudo apt-get install trivy"
                            fi
                        '''
                    } catch (Exception e) {
                        echo "Security scan failed: ${e.getMessage()}"
                        echo "Continuing with deployment..."
                    }
                    
                    echo "‚úÖ Security scan completed"
                }
            }
        }
        
        stage('üì§ Push to Registry') {
            steps {
                script {
                    echo "üì§ Pushing Docker image to registry"
                    
                    docker.withRegistry("https://${params.DOCKER_REGISTRY}", 'docker-hub-credentials') {
                        // Push with build number tag
                        docker.image("${DOCKER_IMAGE}:${BUILD_NUMBER_TAG}").push()
                        
                        // Push environment-specific latest tag
                        docker.image("${DOCKER_IMAGE}:${params.ENVIRONMENT}-latest").push()
                        
                        // Push latest tag for production
                        if (params.ENVIRONMENT == 'production') {
                            docker.image("${DOCKER_IMAGE}:${BUILD_NUMBER_TAG}").push('latest')
                        }
                    }
                    
                    echo "‚úÖ Docker image pushed successfully"
                }
            }
        }
        
        stage('‚ò∏Ô∏è Deploy to Kubernetes') {
            steps {
                script {
                    echo "‚ò∏Ô∏è Deploying to Kubernetes (${params.ENVIRONMENT})"
                    
                    // Apply Kubernetes manifests
                    sh """
                        # Create namespace if it doesn't exist
                        kubectl create namespace ${params.ENVIRONMENT} --dry-run=client -o yaml | kubectl apply -f -
                        
                        # Update deployment image
                        kubectl set image deployment/${params.PROJECT_NAME} \\
                            ${params.PROJECT_NAME}=${DOCKER_IMAGE_FULL} \\
                            -n ${params.ENVIRONMENT}
                        
                        # Wait for rollout to complete
                        kubectl rollout status deployment/${params.PROJECT_NAME} -n ${params.ENVIRONMENT} --timeout=300s
                        
                        # Get deployment status
                        kubectl get pods -n ${params.ENVIRONMENT} -l app=${params.PROJECT_NAME}
                    """
                    
                    echo "‚úÖ Kubernetes deployment completed"
                }
            }
        }
        
        stage('üíö Health Check') {
            steps {
                script {
                    echo "üíö Running health checks"
                    
                    // Get service URL
                    def serviceUrl = sh(
                        script: """
                            kubectl get service ${params.PROJECT_NAME} -n ${params.ENVIRONMENT} \\
                            -o jsonpath='{.spec.clusterIP}:{.spec.ports[0].port}'
                        """,
                        returnStdout: true
                    ).trim()
                    
                    // Health check with retry
                    timeout(time: 5, unit: 'MINUTES') {
                        waitUntil {
                            script {
                                try {
                                    def response = sh(
                                        script: "curl -f http://${serviceUrl}/health || curl -f http://${serviceUrl}/",
                                        returnStatus: true
                                    )
                                    return response == 0
                                } catch (Exception e) {
                                    echo "Health check failed, retrying..."
                                    sleep(10)
                                    return false
                                }
                            }
                        }
                    }
                    
                    echo "‚úÖ Health check passed"
                }
            }
        }
    }
    
    post {
        success {
            script {
                echo "üéâ Deployment completed successfully!"
                
                // Slack notification - Success
                try {
                    slackSend(
                        channel: env.SLACK_CHANNEL,
                        color: 'good',
                        message: "üéâ *${params.PROJECT_NAME}* deployed successfully!\\n" +
                               "üìã Environment: `${params.ENVIRONMENT}`\\n" +
                               "üê≥ Image: `${DOCKER_IMAGE_FULL}`\\n" +
                               "‚è±Ô∏è Duration: `${currentBuild.durationString}`\\n" +
                               "üîó <${BUILD_URL}|View Build>"
                    )
                } catch (Exception e) {
                    echo "Slack notification failed: ${e.getMessage()}"
                }
                
                // Clean up old Docker images
                sh """
                    docker image prune -f
                    docker rmi ${DOCKER_IMAGE}:${BUILD_NUMBER_TAG} || true
                """
            }
        }
        
        failure {
            script {
                echo "‚ùå Deployment failed!"
                
                // Slack notification - Failure
                try {
                    slackSend(
                        channel: env.SLACK_CHANNEL,
                        color: 'danger',
                        message: "‚ùå *${params.PROJECT_NAME}* deployment failed!\\n" +
                               "üìã Environment: `${params.ENVIRONMENT}`\\n" +
                               "üí• Stage: `${env.STAGE_NAME}`\\n" +
                               "‚è±Ô∏è Duration: `${currentBuild.durationString}`\\n" +
                               "üîó <${BUILD_URL}|View Build>"
                    )
                } catch (Exception e) {
                    echo "Slack notification failed: ${e.getMessage()}"
                }
                
                // Rollback on production failure
                if (params.ENVIRONMENT == 'production') {
                    echo "üîÑ Rolling back production deployment"
                    sh """
                        kubectl rollout undo deployment/${params.PROJECT_NAME} -n ${params.ENVIRONMENT}
                        kubectl rollout status deployment/${params.PROJECT_NAME} -n ${params.ENVIRONMENT}
                    """
                }
            }
        }
        
        always {
            script {
                // Archive test results if they exist
                if (fileExists('coverage.xml')) {
                    publishCoverage adapters: [coberturaAdapter('coverage.xml')], sourceFileResolver: sourceFiles('STORE_LAST_BUILD')
                }
                
                // Archive build artifacts
                archiveArtifacts artifacts: 'Dockerfile', allowEmptyArchive: true
                
                // Clean workspace
                cleanWs()
            }
        }
    }
}
